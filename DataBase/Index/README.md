# 데이터베이스 인덱스(Database Index)

## 인덱스란?

데이터베이스 인덱스는 테이블 내의 한 열(column) 이상을 대상으로 생성되며, 데이터를 더 빠르게 조회하기 위한 자료구조이다.  
인덱스는 특정 열의 데이터값과 그 값이 있는 레코드를 식별하는 포인터를 매핑하는 테이블

## 인덱스를 사용하는 이유
인덱스를 사용하는 주된 이유는 **데이터 조회 속도를 향상**시키기 위해서이다.   
인덱스가 없는 경우, 데이터베이스는 테이블 전체를 스캔(Full Table Scan)해야 하지만, 인덱스가 있는 경우, 데이터베이스는 인덱스를 통해 레코드를 빠르게 찾아낼 수 있습니다.

## 인덱스의 자료구조
인덱스는 여러 가지 자료구조를 사용할 수 있지만, 가장 흔하게 사용되는 자료구조는 B-Tree와 Hash

### B-Tree
대부분의 데이터베이스 인덱스는 B-Tree 자료구조를 사용합니다. B-Tree 인덱스는 데이터를 정렬하여 저장하므로, 범위 검색이나 정렬된 결과를 빠르게 얻는 데 유리하다.
  - MySQL의 **InnoDB**와 **MyISAM** 스토리지 엔진
  - **Oracle**도 B-Tree 인덱스를 기본 인덱스 자료구조로 사용

![image](https://github.com/minsu20/CS_Study/assets/86006389/a925aa33-7b97-4ec4-90bf-8b1a801751c1)
차수가 3인 B트리 이다. 파란색 부분은 각 노드의 key를 나타내며, 빨간색 부분은 자식 노드들을 가르키는 포인터이다. key들은 노드 안에서 항상 정렬된 값을 가지며, 이진검색 트리처럼 각 key들의 왼쪽 자식들은 항상 key보다 작은 값을, 오른쪽은 큰 값을 가진다.


### Hash
Hash 인덱스는 키를 해시 함수에 통과시켜 나온 결과에 따라 데이터를 저장하므로, 정확한 값을 찾는 검색에는 빠르지만 범위 검색이나 정렬된 결과를 얻는 데는 부적합하다.
  - MySQL의 **MEMORY** 스토리지 엔진은 Hash 인덱스를 지원

## 인덱스의 장점
1. **데이터 조회 성능 향상**
   

2. **정렬된 데이터의 빠른 접근**

## 인덱스의 단점

1. **저장 공간 사용**
   
2. **데이터 변경의 부담**

## 인덱스와 JPA

JPA에서는 `@Id` 어노테이션을 이용해 엔티티의 필드를 테이블의 기본 키(primary key)로 매핑한다.
기본 키는 각 행을 고유하게 식별하는 역할을 하고, 데이터베이스에서 기본 키는 자동으로 인덱스로 설정되기 때문에, `@Id` 어노테이션이 지정된 필드는 이미 인덱스로서의 역할을 한다.


### 인덱스 생성

추가로 다른 열에 인덱스를 만들기 원한다면, JPA에서는 `@Index` 어노테이션을 사용하여 인덱스를 만들 수 있다. 이때, `columnList` 속성에 인덱스를 생성하고자 하는 열의 이름을 적어주면 된다.

예를 들어, `name` 열에 인덱스를 만들고 싶다면 아래와 같이 `@Index` 어노테이션을 사용할 수 있다

```java
@Table(name = "team", indexes = {@Index(name = "index_name", columnList = "name")})
```

## 인덱스를 고려해야 하는 상황

인덱스는 조회 성능을 향상시키지만, 동시에 추가적인 저장 공간을 사용하고 데이터 변경에 따른 부담을 주기에 인덱스를 생성할 때는 다음과 같은 사항을 고려해야 한다!

- 해당 열이 WHERE, JOIN, ORDER BY 등의 조건절에 자주 사용되는지
- 해당 열의 데이터가 충분히 고유한지 (고유한 값이 많을수록 인덱스의 효율이 높아짐)
- 해당 열의 데이터가 자주 변경되는지



