### 동기&비동기 / 블로킹&논블로킹

- 동기&비동기는 요청한 작업에 대해, 완료 여부를 확인하여 작업을 순차적으로 수행할 지, 아닐 지에 대한 관점.
- 블로킹&논블로킹은 말 그대로 현재 작업이 Block되는지, 아닌지에 따라 다른 작업을 수행할 수 있는 지에 대한 관점.



## 동기와 비동기 (Synchronous / Asynchronous)

- Synchronous (동기)
  - 요청한 작업의 완료 여부를 확인하고, 완료 이후에 순차적으로 다음 작업을 처리하기 시작하는 것.
- Asynchronous (비동기)
  - 요청한 작업의 완료 여부에 관계없이, 바로 다음 작업을 수행하기 시작하는 것.
- 따라서, Input/Output이나 API 통신과 같이 느린 작업이 발생할 때, 비동기 방식이 성능에 훨씬 유리하다.



## 블로킹과 논블로킹 (Blocking / Non-Blocking)

- 다른 작업을 처리하기 위해, 현재 작업을 block할 것인지, 하지 않을 것인지의 여부를 결정하는, 프로세스의 실행 방식.
- 동기&비동기가 작업의 순차적 흐름에 대한 것이라면, 블로킹&논블로킹은 전체적인 작업의 흐름을 막을 것인지 여부.



- 블로킹은 요청에 대한 결과가 return될 때까지 대기하는 것.
  - 동기(Synchronous)와는 다르다. 동기는 하나의 실행 흐름에서, return을 기다릴 것인지, 기다리지 않을 것인지의 차이라면,
    블로킹은 그 흐름 자체를 정지시킬 지, 정지시키지 않을 지의 여부이다.
  - 예를 들어, A 함수에서 B 함수를 호출 후, B함수에서 값을 return해줄 때까지 A함수 자체를 '정지' 시킨다면 -> 이것은 블로킹이다.
  - 동기는 느낌이 다르다. A함수에 B함수를 호출 후, B함수에서 return될 때까지 A함수에서 B함수에 지속적으로 작업 완료 여부를 확인하고, 비로소 B함수가 return되면, A함수 내의 다음 작업을 수행하기 시작하는 것이다.
  - 가장 중요한 것은, '제어권(주체성)'이다. 위의 예시에서, 블로킹이라면 제어권은 A함수에서 B함수로 넘어가게 되는 것이고, 동기라면 A함수가 계속 제어권을 들고 있는 느낌이다.
