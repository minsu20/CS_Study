# TCP와 UDP 차이점
| 항목 | TCP | UDP |
|:-----:|:------:|:------:|
|연결방식|연결형 서비스: 3-way handshake로 연결|비연결형 서비스|
|데이터 전송 방식|바이트 스트림 전송|메세지 스트림 전송|
|흐름제어|제공: 수신량 조절 가능|제공하지 않음|
|혼잡제어|제공: 네트워크 내 패킷 수 조절 가능|제공하지 않음|
|전송 속도|상대적으로 느림|상대적으로 빠름|
|전송 신뢰성|높음: 재전송 요구 가능|낮음|
|데이터 단위|세그먼트|데이터그램|
|주요 사용분야|HTTP, 이메일, 파일 전송 등|DNS, 실시간 스트리밍 등|


## 3-way handshake(연결 설정)
![image](https://github.com/minsu20/CS_Study/assets/86006389/55b2d66e-55a4-4a12-99e0-1e1e2ecb9cba)

### [STEP 1] 클라이언트 -> 서버: SYN
클라이언트가 서버에게 "연결해주세요"라는 요청을 보낸다.  
```
클라이언트는 서버에게 연결을 요청하는 SYN 패킷을 보낸다.  
이 패킷을 보낸 후, 클라이언트는 SYN_SENT 상태로 들어간다.
```

### [STEP 2] 서버 -> 클라이언트: SYN+ACK
서버가 클라이언트에게 "요청을 받았습니다, 연결이 가능합니다"라는 응답을 보낸다.
```
서버는 이 SYN 패킷을 받으면, 클라이언트에게 SYN와 ACK를 동시에 보낼 수 있는 SYN+ACK 패킷을 보낸다.  
이 패킷을 보낸 후, 서버는 SYN_RCVD 상태로 전환.
```

### [STEP 3] 클라이언트 -> 서버: ACK
클라이언트가 서버에게 "확인했습니다, 이제 연결을 시작해도 됩니다"라는 메시지를 보낸다.
```
클라이언트는 이 SYN+ACK 패킷을 받으면, 서버에게 ACK 패킷을 보낸다.  
이 패킷을 보낸 후, 클라이언트는 ESTABLISHED 상태로 전환.  
서버 역시 클라이언트로부터 ACK 패킷을 받으면, ESTABLISHED 상태로 전환.
```

## 4-way handshake(연결 해제)
![image](https://github.com/minsu20/CS_Study/assets/86006389/094094f0-f853-4071-823b-b6da51c9c1df)

### [STEP 1] 클라이언트 -> 서버: FIN
클라이언트가 서버에게 "이제 연결을 종료하겠습니다"라는 메시지를 보낸다.
```
종료하고자 하는 클라이언트는 서버에게 FIN 플래그가 설정된 세그먼트를 보내고, 자신은 FIN_WAIT_1 상태로 들어간다.
```

### [STEP 2] 서버 -> 클라이언트: ACK
서버가 클라이언트에게 "연결 종료 요청을 받았습니다"라는 메시지를 보낸다.
```
서버는 FIN 세그먼트를 받으면 ACK를 클라이언트에게 보내고, 자신은 CLOSE_WAIT 상태로 변경된다.
이 때, 클라이언트는 FIN_WAIT_2 상태로 전환.
```

### [STEP 3] 서버 -> 클라이언트: FIN
서버가 모든 데이터를 클라이언트에게 보내고 "이제 저도 연결을 종료하겠습니다"라는 메시지를 보낸다.
```
서버가 아직 보내지 않은 데이터가 있으면 보낼 수 있으며, 모든 데이터를 보낸 후에 서버는 FIN 세그먼트를 클라이언트에게 보낸다.
이 때, 서버는 LAST_ACK 상태로 전환된다.
```

### [STEP 4] 클라이언트 -> 서버: ACK
클라이언트가 서버에게 "연결 종료 요청을 받았습니다"라는 메시지를 보낸다.
```
클라이언트는 서버의 FIN 세그먼트를 받으면, ACK 세그먼트를 서버에게 보내고, 자신은 TIME_WAIT 상태로 전환된다.
이 상태는 임의의 시간동안 유지되며, 이 기간은 보통 2*MSL(Maximum Segment Lifetime).  
서버는 클라이언트로부터의 ACK 세그먼트를 받으면, 자신은 CLOSED 상태로 전환.  
클라이언트의 TIME_WAIT 상태가 끝나면, 클라이언트 역시 CLOSED 상태로 전환.
```
